<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Routine Generator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Select2 CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 40px;
        background-color: #f2f2f2;
      }

      .container {
        background-color: #fff;
        padding: 25px;
        border-radius: 10px;
        max-width: 800px;
        margin: auto;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      }

      label {
        font-weight: bold;
        display: block;
        margin-top: 20px;
        margin-bottom: 10px;
      }

      input,
      select,
      button {
        padding: 10px;
        font-size: 16px;
        width: 100%;
        box-sizing: border-box;
      }

      .select2-container {
        width: 100% !important;
      }

      #routineOutput {
        margin-top: 30px;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
        background-color: white;
      }

      th,
      td {
        border: 1px solid #ccc;
        padding: 8px;
        text-align: left;
      }

      th {
        background-color: #e0e0e0;
      }

      .selected-item {
        background-color: #e6f7ff;
        padding: 8px 12px;
        border: 1px solid #91d5ff;
        border-radius: 4px;
        margin: 5px 0;
      }
      #loadingSpinner {
        display: none;
        border: 8px solid #f3f3f3;
        border-top: 8px solid #3498db;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        animation: spin 1s linear infinite;
        margin: 20px auto;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style>

    <!-- JS Libraries -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <script>
      // Set PDF.js worker source
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';
    </script>
  </head>
  <body>
    <div class="container">
      <h2>üìÖ Routine Generator</h2>

      <label for="fileInput">Upload Routine File (Excel or PDF):</label>
      <input type="file" id="fileInput" accept=".xlsx,.pdf" />

      <label for="courseMultiSelect">Select Courses:</label>
      <select id="courseMultiSelect" multiple></select>

      <button onclick="generateRoutines()">Generate Routines</button>

      <div
        id="loadingSpinner"
        style="display: none; text-align: center; margin-top: 20px"
      >
        <div class="spinner"></div>
        <p>Loading, please wait...</p>
      </div>

      <div id="routineOutput"></div>
      <div id="loadingSpinner"></div>
    </div>

    <script>
      function showSpinner() {
        document.getElementById("loadingSpinner").style.display = "block";
      }
      function hideSpinner() {
        document.getElementById("loadingSpinner").style.display = "none";
      }

      let scheduleData = [];

      document
        .getElementById("fileInput")
        .addEventListener("change", async function (e) {
          const file = e.target.files[0];
          if (!file) return;

          const ext = file.name.split(".").pop().toLowerCase();

          if (ext === "xlsx") {
            handleExcel(file);
          } else if (ext === "pdf") {
            handlePDF(file);
          } else {
            alert("Unsupported file type");
          }
        });

      function parseTableFormat(lines) {
        const parsed = [];
        
        console.log("Processing lines:", lines); // Debug log

        // Concatenate all lines into one big text
        const fullText = lines.join(' ');
        
        // Parse the full text
        const spaceParsed = parseSpaceSeparatedFormat(fullText);
        parsed.push(...spaceParsed);

        console.log("Parsed data from space format:", parsed); // Debug log
        return parsed;
      }

      function parseSpaceSeparatedFormat(text) {
        const parsed = [];
        
        // Split by multiple spaces and filter out empty strings
        const parts = text.split(/\s+/).filter(part => part.trim() !== '');
        console.log("Space separated parts:", parts.slice(0, 50)); // Debug log first 50 parts

        // Find the start of actual course data (after "ROOM")
        let startIndex = 0;
        const roomIndex = parts.indexOf("ROOM");
        if (roomIndex !== -1) {
          startIndex = roomIndex + 1;
        }

        // Process course entries starting from startIndex
        for (let i = startIndex; i < parts.length - 7; i++) {
          // Check if this part is a 5-digit CODE
          if (/^\d{5}$/.test(parts[i])) {
            const code = parts[i];
            const courseId = parts[i + 1];
            
            // Course name starts at i+2 and continues until we find a single letter A-Z (section)
            let courseName = '';
            let sectionIndex = i + 2;
            
            while (sectionIndex < parts.length && !/^[A-Z]$/.test(parts[sectionIndex])) {
              if (sectionIndex > i + 2) courseName += ' ';
              courseName += parts[sectionIndex];
              sectionIndex++;
            }
            
            if (sectionIndex < parts.length - 5) {
              const section = parts[sectionIndex];
              const timeStart = parts[sectionIndex + 1];
              
              if (parts[sectionIndex + 2] === '-') {
                const timeEnd = parts[sectionIndex + 3];
                const day = parts[sectionIndex + 4];
                const room = parts[sectionIndex + 5];
                
                const entry = {
                  "Course Title": courseName.trim(),
                  "Course ID": courseId,
                  "CODE": code,
                  Section: section,
                  "Start Time": timeStart + ":00",
                  "End Time": timeEnd + ":00",
                  Day: day,
                  Room: room,
                  times: [{
                    day: day,
                    startRaw: timeStart + ":00",
                    endRaw: timeEnd + ":00",
                    start: convertTo24Hour(timeStart + ":00"),
                    end: convertTo24Hour(timeEnd + ":00"),
                    room: room
                  }]
                };
                
                parsed.push(entry);
                console.log("Parsed entry:", entry); // Debug log
                
                // Skip to next course (move past this entry)
                i = sectionIndex + 5;
              }
            }
          }
        }
        
        console.log("Parsed " + parsed.length + " courses from space-separated format");
        return parsed;
      }

      function convertTo24Hour(time) {
        if (!time) return 0;
        const cleaned = time.trim();
        const parts = cleaned.split(/\s+/); // may contain AM/PM as separate token
        let timePart = parts[0];
        let modifier = parts[1] ? parts[1].toLowerCase() : null;
        // Drop trailing seconds if present (HH:MM:SS)
        const hm = timePart.split(":");
        let hours = parseInt(hm[0], 10);
        let minutes = parseInt(hm[1] || '0', 10);
        if (modifier === 'pm' && hours < 12) hours += 12;
        if (modifier === 'am' && hours === 12) hours = 0;
        if (!modifier) {
          // Heuristic: schedule uses 1,2,3,4,5,6 for afternoon/evening (13-18)
            if (hours >= 1 && hours <= 6) hours += 12; // treat as 13..18
        }
        return hours + minutes / 60;
      }

      // Helper to normalize course titles by removing bracketed qualifiers like [FST/FE]
      function removeBrackets(title) {
        if (!title || typeof title !== 'string') return title;
        return title.replace(/\[[^\]]*\]/g, '').replace(/\s+/g, ' ').trim();
      }

      function handleExcel(file) {
        showSpinner();
        const reader = new FileReader();
        reader.onload = function (e) {
          const workbook = XLSX.read(e.target.result, { type: "binary" });
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          const json = XLSX.utils.sheet_to_json(sheet);
          
          // Convert Excel format to expected format
          const converted = json.map(row => ({
            "Course Title": row["COURSE"] || row["Course"],
            "Course ID": row["Course ID"],
            "CODE": row["CODE"],
            Section: row["SEC"],
            "Start Time": row["TIME"] ? row["TIME"].split("-")[0] + ":00" : "",
            "End Time": row["TIME"] ? row["TIME"].split("-")[1] + ":00" : "",
            Day: row["DAY"],
            Room: row["ROOM"],
            times: [{
              day: row["DAY"],
              startRaw: row["TIME"] ? row["TIME"].split("-")[0] + ":00" : "",
              endRaw: row["TIME"] ? row["TIME"].split("-")[1] + ":00" : "",
              start: convertTo24Hour(row["TIME"] ? row["TIME"].split("-")[0] + ":00" : ""),
              end: convertTo24Hour(row["TIME"] ? row["TIME"].split("-")[1] + ":00" : ""),
              room: row["ROOM"]
            }]
          }));
          
          parseRows(converted);
          hideSpinner();
        };
        reader.readAsBinaryString(file);
      }

      async function handlePDF(file) {
        showSpinner();
        const reader = new FileReader();
        reader.onload = async function () {
          const typedarray = new Uint8Array(reader.result);
          const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;
          let text = "";

          for (let i = 1; i <= pdf.numPages; i++) {
            const page = await pdf.getPage(i);
            const content = await page.getTextContent();
            const strings = content.items.map((item) => item.str).join(" ");
            text += strings + "\n";
          }

          console.log("Extracted PDF text:", text.substring(0, 200) + "..."); // Debug log (truncated)

          const lines = text.split("\n").filter(line => line.trim() !== "");

          const parsed = parseTableFormat(lines);
          console.log("Parsed data:", parsed); // Debug log

          parseRows(parsed);
          hideSpinner();
        };
        reader.readAsArrayBuffer(file);
      }

      function updateCourseDropdown() {
        console.log("Updating course dropdown with data:", scheduleData); // Debug log

        const uniqueTitles = [
          ...new Set(scheduleData.map((item) => item.title)),
        ];

        console.log("Unique course titles:", uniqueTitles); // Debug log

        const multiSelect = document.getElementById("courseMultiSelect");
        multiSelect.innerHTML = "";

        if (uniqueTitles.length === 0) {
          alert("No courses found in the uploaded file. Please check the file format.");
          return;
        }

        uniqueTitles.forEach((title) => {
          const option = document.createElement("option");
          option.value = title;
          option.textContent = title;
          multiSelect.appendChild(option);
        });

        setTimeout(() => {
          $("#courseMultiSelect").select2({
            placeholder: "Search and select courses",
            width: "resolve",
          });
        }, 0);

        alert(`File uploaded successfully! Found ${uniqueTitles.length} unique courses.`);
      }

      function parseRows(rows) {
        console.log("parseRows input:", rows); // Debug log

  const grouped = {}; // key: title__section -> {title, section, times: [...]} (times already expanded below)

        function expandCompositeDays(day) {
          if (!day) return [];
            const d = day.trim();
            if (d === 'ST') return ['S','T'];
            if (d === 'MW') return ['M','W'];
            if (d === 'TH') return ['TH']; // Thursday single token
            // Sometimes single letter already
            return [d];
        }

        rows.forEach((row) => {
          // Preserve bracket qualifiers (e.g., [FBA/FASS] vs [FST/FE]) so they are distinct courses
          const title = (row["Course Title"] || "").trim();
          const section = row["Section"] || "A";
          const key = `${title}__${section}`;
          const originalTimes = row.times || [];
          const expandedTimes = [];
          originalTimes.forEach(t => {
            const days = expandCompositeDays(t.day);
            days.forEach(singleDay => {
              // Clone & normalize
              let startNum = convertTo24Hour(t.startRaw);
              let endNum = convertTo24Hour(t.endRaw);
              if (endNum <= startNum) {
                endNum += 12; // adjust for afternoon wrap
              }
              expandedTimes.push({
                ...t,
                day: singleDay,
                start: startNum,
                end: endNum
              });
            });
          });

          if (!grouped[key]) {
            grouped[key] = { title, section, times: expandedTimes };
          } else {
            grouped[key].times.push(...expandedTimes);
          }
        });

        // Transform into scheduleData: [{title, sections:[{section, times:[...]}, ...]}]
        const byTitle = {};
        Object.values(grouped).forEach(entry => {
          if (!byTitle[entry.title]) byTitle[entry.title] = { title: entry.title, sections: [] };
          byTitle[entry.title].sections.push({ section: entry.section, times: entry.times });
        });
        scheduleData = Object.values(byTitle);
        console.log("Final scheduleData (section grouped):", scheduleData);

        updateCourseDropdown();
      }

      function hasConflict(a, b) {
        if (a.day !== b.day) return false;
        return !(a.end <= b.start || b.end <= a.start);
      }

      function forwardChecking(
        variables,
        assignment,
        domains,
        results,
        depth = 0
      ) {
        if (assignment.length === variables.length) {
          results.push([...assignment]);
          return;
        }

        const varIndex = assignment.length;
        const variable = variables[varIndex];

        for (let option of domains[variable]) {
          let conflict = false;

          for (let i = 0; i < assignment.length; i++) {
            const other = assignment[i];
            if (hasConflict(option, other)) {
              conflict = true;
              break;
            }
          }

          if (!conflict) {
            assignment.push(option);
            forwardChecking(variables, assignment, domains, results, depth + 1);
            assignment.pop();
          }
        }
      }

      function generateRoutines() {
        const selectedCourses = $("#courseMultiSelect").val();
        if (!selectedCourses.length) {
          alert("Please select at least one course");
          return;
        }

        // Build domains where each option = whole section with all its sessions
        const domains = {};
        selectedCourses.forEach(course => {
          const courseEntry = scheduleData.find(e => e.title === course);
          if (!courseEntry) { domains[course] = []; return; }
          domains[course] = courseEntry.sections.map(sec => ({
            title: courseEntry.title,
            section: sec.section,
            times: sec.times
          }));
        });

        const variables = selectedCourses;
        const results = [];
        // Modified forward checking for section objects
        function search(idx, current) {
          if (idx === variables.length) { results.push([...current]); return; }
          const course = variables[idx];
          for (const option of domains[course]) {
            let conflict = false;
            for (const chosen of current) {
              for (const t1 of option.times) {
                for (const t2 of chosen.times) {
                  if (hasConflict(t1, t2)) { conflict = true; break; }
                }
                if (conflict) break;
              }
              if (conflict) break;
            }
            if (!conflict) { current.push(option); search(idx+1, current); current.pop(); }
          }
        }
        search(0, []);

        // Compute idle time score (sum of gaps between sessions same day) lower is better
        function computeIdleScore(routine) {
          const byDay = {};
          routine.forEach(section => {
            section.times.forEach(t => {
              if (!byDay[t.day]) byDay[t.day] = [];
              byDay[t.day].push({start:t.start, end:t.end});
            });
          });
          let totalGap = 0;
            Object.values(byDay).forEach(list => {
              list.sort((a,b)=> a.start - b.start);
              for (let i=0;i<list.length-1;i++) {
                const gap = list[i+1].start - list[i].end;
                if (gap > 0) totalGap += gap; // hours
              }
            });
          return totalGap; // in hours
        }

        const scored = results.map(r => ({ routine: r, score: computeIdleScore(r) }));
        scored.sort((a,b)=> a.score - b.score);

        const outputDiv = document.getElementById("routineOutput");
        outputDiv.innerHTML = "";

        if (scored.length === 0) {
          outputDiv.innerHTML =
            "<p>No valid routines found without conflicts.</p>";
          return;
        }

        scored.slice(0, 3).forEach((entry, index) => {
          const routine = entry.routine;
          const table = document.createElement("table");
          const header = document.createElement("tr");
          header.innerHTML =
            "<th>Course</th><th>Section</th><th>Day</th><th>Start</th><th>End</th><th>Room</th>";
          table.appendChild(header);
          // Flatten sessions with course/section info
          const flat = [];
          routine.forEach(sectionChoice => {
            sectionChoice.times.forEach(session => {
              flat.push({
                title: sectionChoice.title,
                section: sectionChoice.section,
                day: session.day,
                startRaw: session.startRaw,
                endRaw: session.endRaw,
                room: session.room || 'N/A',
                startNum: convertTo24Hour(session.startRaw)
              });
            });
          });

          // Group by same course/section/time/room to recombine multi-day patterns (e.g., S + T -> ST)
          const groupingMap = {};
          flat.forEach(item => {
            const key = `${item.title}|${item.section}|${item.startRaw}|${item.endRaw}|${item.room}`;
            if (!groupingMap[key]) {
              groupingMap[key] = { ...item, days: [item.day] };
            } else if (!groupingMap[key].days.includes(item.day)) {
              groupingMap[key].days.push(item.day);
            }
          });

          const dayOrder = ['S','M','T','W','TH','F','SA'];
          const dayIndex = d => {
            const idx = dayOrder.indexOf(d);
            return idx === -1 ? 99 : idx;
          };

          const groupedFlat = Object.values(groupingMap).map(g => {
            g.days.sort((a,b)=> dayIndex(a)-dayIndex(b));
            // Merge consecutive common patterns specifically ST, MW
            const dayStr = g.days.join('');
            return { ...g, dayDisplay: dayStr, primaryDay: g.days[0] };
          });

          groupedFlat.sort((a,b)=>{
            const di = dayIndex(a.primaryDay) - dayIndex(b.primaryDay);
            if (di !== 0) return di;
            return a.startNum - b.startNum;
          });

          groupedFlat.forEach(item => {
            const row = document.createElement('tr');
            row.innerHTML = `<td>${item.title}</td><td>${item.section}</td><td>${item.dayDisplay}</td><td>${item.startRaw}</td><td>${item.endRaw}</td><td>${item.room}</td>`;
            table.appendChild(row);
          });

          const heading = document.createElement("h3");
          const idleMins = Math.round(entry.score * 60);
          heading.textContent = `üóìÔ∏è Routine Option ${index + 1} (Idle gap: ${Math.floor(idleMins/60)}h ${idleMins%60}m)`;

          outputDiv.appendChild(heading);
          outputDiv.appendChild(table);
        });
      }
    </script>
  </body>
</html>
